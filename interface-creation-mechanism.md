# Interface Creation Mechanism: Complete Analysis

**Date**: 2026-02-17
**Status**: Investigation in progress

## Key Findings

### 1. porttab File Generation

**Location**: `/var/lib/cumulus/porttab`
**Generator**: `/usr/lib/cumulus/update-ports`
**Format**:
```
# Automatically generated by /usr/lib/cumulus/update-ports.
linux_intf	sdk_intf	unit	is_fabric
swp1	xe0	0	0
swp2	xe1	0	0
...
```

**Purpose**: Maps Linux interface names (swp1-52) to BCM SDK port names (xe0-xe51).

### 2. Platform Initialization

**Location**: `/usr/share/cumulus/.installer/cumulus/init/accton_as5610_52x`

This script likely:
- Creates swp interfaces before switchd starts
- Generates porttab file
- Sets up platform-specific configuration

### 3. switchd Init Script

**Location**: `/etc/init.d/switchd`

**Key steps**:
1. Acquires lock (`/var/run/switchd.init.lock`)
2. Runs `ifupdown_ethtool_replay.sh` (replays ethtool commands)
3. Starts switchd daemon
4. switchd reads porttab and maps interfaces

## Interface Creation Hypothesis

### Theory 1: Platform Script Creates Interfaces

The platform init script (`accton_as5610_52x`) likely:
1. switchd creates swp1-52 via TUN (open /dev/net/tun, TUNSETIFF "swpN")
2. Generates porttab via `update-ports`
3. switchd starts and reads porttab

### Theory 2: SDK Creates Interfaces

The SDK might create interfaces during initialization:
- `bcm_attach()` creates netdevs via BDE
- Platform-specific SDK hooks register interfaces
- Interfaces appear before switchd reads porttab

### Theory 3: Kernel Module Creates Interfaces

A platform-specific kernel module might:
- Register swp1-52 netdevs during module load
- Use `register_netdev()` or `rtnl_link_register()`
- Interfaces exist before switchd starts

## Investigation Steps

### Step 1: Check update-ports Script

```bash
cat /usr/lib/cumulus/update-ports
```

This script likely:
- Reads platform config (rc.ports_0)
- Creates interfaces if they don't exist
- Generates porttab file

### Step 2: Check Platform Init Script

```bash
cat /usr/share/cumulus/.installer/cumulus/init/accton_as5610_52x
```

This script likely:
- Runs before switchd
- Creates swp interfaces
- Calls update-ports

### Step 3: Check Boot Sequence

```bash
# Check when interfaces appear
dmesg | grep -i swp

# Check init.d order
ls -la /etc/rc*.d/ | grep switch
```

### Step 4: Check Kernel Modules

```bash
# Look for platform modules
lsmod | grep -E 'accton|as5610'

# Check module info
modinfo <module>
```

## Implementation Strategy

### Option A: Pre-create Interfaces (Recommended)

Create a platform initialization script that:

```bash
#!/bin/bash
# Create swp interfaces before switchd starts

for i in {1..52}; do
    if ! ip link show swp$i >/dev/null 2>&1; then
        # Use TUN: open /dev/net/tun, ioctl(TUNSETIFF, "swp$i")
    fi
done

# Generate porttab
/usr/lib/cumulus/update-ports
```

**Pros**:
- Simple and reliable
- Matches Cumulus behavior
- No kernel module needed

**Cons**:
- Requires platform-specific script
- Interfaces are TUN type (switchd reads/writes packets; no dummy)

### Option B: SDK Creates Interfaces

Investigate if OpenNSL SDK can create interfaces:
- Check SDK initialization hooks
- Look for interface creation APIs
- May require custom netdev ops

**Pros**:
- More integrated with SDK
- Can provide hardware ops

**Cons**:
- May not be supported by OpenNSL
- More complex

### Option C: Kernel Module

Create a kernel module that registers swp1-52:
- Module loads before switchd
- Registers netdevs with `register_netdev()`
- Provides netdev ops for packet I/O

**Pros**:
- Most "native" approach
- Can provide full netdev functionality

**Cons**:
- Requires kernel module development
- More complex than needed

## Recommended Approach

**Use Option A** (pre-create interfaces):

1. **Create platform init script** (`/etc/init.d/platform-init`):
   - Creates swp1-52 via TUN (like Cumulus switchd)
   - Runs before switchd

2. **Generate porttab**:
   - Use `update-ports` script (or equivalent)
   - Maps swpX to BCM ports

3. **switchd reads porttab**:
   - Uses existing `port_mapper` component
   - Maps Linux interfaces to BCM ports

4. **Packet I/O**:
   - Interfaces are TUN type
   - Packet I/O handled via SDK/BDE (not through netdev)
   - Control plane packets use SDK packet APIs

## Next Steps

1. **Read update-ports script** - Understand how it creates interfaces
2. **Read platform init script** - See exact initialization sequence
3. **Test interface creation** - Create swp interfaces manually
4. **Implement platform init** - Create our own init script
5. **Test with switchd** - Verify interfaces work with switchd

## References

- [interface-creation-analysis.md](interface-creation-analysis.md) - Initial analysis
- [NO_KNET_ARCHITECTURE.md](../NO_KNET_ARCHITECTURE.md) - Architecture differences
- [porttab.py](porttab.py) - Python porttab parser
