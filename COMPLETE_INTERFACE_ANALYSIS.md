# Complete Interface Creation Analysis

**Date**: 2026-02-17
**Status**: Analysis complete - interfaces are virtual netdevs created before switchd

## Executive Summary

**Finding**: Cumulus creates swp1-52 as **virtual network devices** (`/devices/virtual/net/swp1`) **before switchd starts**. switchd then maps these existing interfaces to BCM ports via the porttab file.

## Key Discoveries

### 1. Interface Type: Virtual Netdevs

```bash
$ ls -la /sys/class/net/swp1
lrwxrwxrwx swp1 -> ../../devices/virtual/net/swp1
```

**Not physical driver interfaces** - they're virtual netdevs created via Linux kernel APIs.

### 2. porttab File

**Location**: `/var/lib/cumulus/porttab`
**Generator**: `/usr/lib/cumulus/update-ports` (Python script)
**Format**:
```
linux_intf	sdk_intf	unit	is_fabric
swp1	xe0	0	0
swp2	xe1	0	0
...
```

**Purpose**: Maps Linux interface names to BCM SDK port names.

### 3. update-ports Script

**Location**: `/usr/lib/cumulus/update-ports`

**Function**:
- Reads `/etc/cumulus/ports.conf`
- Uses `cumulus.portconfig` Python module
- Generates porttab file
- **Does NOT create interfaces** - only generates mapping

### 4. switchd Initialization

**Sequence**:
1. Interfaces **already exist** when switchd starts
2. switchd reads porttab file
3. switchd maps swpX to BCM ports (xe0-xe51)
4. switchd logs: `porttab entry, linux:swp1 sdk:xe0`

## Interface Creation Mechanism

### Hypothesis: SDK Creates Interfaces

The most likely mechanism:

1. **BDE kernel module** (`linux-kernel-bde.ko`) creates virtual netdevs during initialization
2. **SDK initialization** (`bcm_attach()` / `bcm_init()`) triggers interface creation
3. **Interfaces appear** before switchd reads porttab
4. **switchd maps** existing interfaces to BCM ports

### Alternative: Platform Script

Less likely but possible:

1. **switchd** creates interfaces via TUN (open /dev/net/tun, ioctl TUNSETIFF with name swp1, etc.)
2. **update-ports** generates porttab
3. **switchd** reads porttab and maps interfaces

## Evidence

### From switchd Log

```
hal_bcm_port.c:56 porttab entry, linux:swp1 sdk:xe0
```

This shows interfaces **already exist** - switchd is just mapping them.

### From porttab File

```
# Automatically generated by /usr/lib/cumulus/update-ports.
```

Generated before switchd starts (timestamp: 12:08:49, switchd starts at 12:09:08).

### From sysfs

```
/devices/virtual/net/swp1
```

Virtual netdev, not physical driver interface.

## Implementation Strategy

### For Open-Source NOS

**Option 1: Pre-create Interfaces (Recommended)**

Create swp1-52 interfaces before switchd starts:

```bash
#!/bin/bash
# Platform initialization script

# Create swp interfaces
for i in {1..52}; do
    if ! ip link show swp$i >/dev/null 2>&1; then
        # Cumulus uses TUN: open /dev/net/tun, TUNSETIFF "swp$i"
    fi
done

# Generate porttab (or create manually)
# swp1 -> xe0 (BCM port 1)
# swp2 -> xe1 (BCM port 2)
# ...
```

**Pros**:
- Simple and reliable
- Matches Cumulus behavior
- No kernel module needed

**Cons**:
- Interfaces are TUN type (verified: /sys/class/net/swpN/tun_flags exists; dummy module not loaded)
- Packet I/O handled via SDK, not netdev ops

### Option 2: SDK Creates Interfaces

Investigate if OpenNSL SDK can create interfaces:
- Check SDK initialization hooks
- Look for interface creation APIs
- May require custom netdev ops

**Pros**:
- More integrated with SDK
- Can provide hardware ops

**Cons**:
- May not be supported by OpenNSL
- More complex

## Packet I/O Without KNET

### Control Plane Packets

**Flow**:
1. Application sends packet via socket
2. Linux kernel routes to swpX interface
3. **swpX netdev** â†’ **SDK packet API** (via BDE)
4. SDK handles packet TX via BDE DMA
5. ASIC transmits packet

**Key**: No KNET driver - SDK handles packet I/O directly through BDE.

### Data Plane Packets

**Same as before** - pure hardware forwarding, no CPU involvement.

## Next Steps

1. **Test interface creation** - Create swp1-52 manually
2. **Test with switchd** - Verify interfaces work
3. **Implement platform init** - Create initialization script
4. **Investigate SDK packet APIs** - Find non-KNET packet I/O methods
5. **Test packet I/O** - Verify control plane packets work

## References

- [interface-creation-analysis.md](interface-creation-analysis.md) - Initial analysis
- [interface-creation-mechanism.md](interface-creation-mechanism.md) - Mechanism details
- [NO_KNET_ARCHITECTURE.md](../NO_KNET_ARCHITECTURE.md) - Architecture differences
- [cumulus-packet-io-architecture.md](cumulus-packet-io-architecture.md) - Packet I/O details
